<!DOCTYPE html>
<!-- 
Chosen Palette: Cyberpunk Neon (Primary: #00ffcc, Secondary: #ff00ff, Background: #0a0c10)
Application Structure Plan: This version fixes a critical ReferenceError caused by an incomplete script from a previous edit. The full JavaScript logic, including all function definitions, element references, and event listener attachments, has been restored.
Visualization & Content Choices: 
- Feature: Bug Fix. Goal: Resolve startup ReferenceError by restoring the complete codebase.
- Viz/Presentation: No visual changes.
- Interaction: The application now runs without crashing. The welcome screen appears, and all subsequent buttons and modals are functional.
- Justification: Restores the full, correct codebase, fixing the critical error that prevented the application from initializing correctly.
-->
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>CORTEX Anomaly Detector | Cyberpunk Ansiktsgjenkjenning</title>
    <meta name="description" content="En cyberpunk-inspirert ansiktsgjenkjenning-app som bruker en full suite av AI-funksjoner, inkludert en innebygd hjelpeseksjon.">
    <meta name="keywords" content="ansiktsgjenkjenning, adferdsanalyse, AI, kunstig intelligens, cyberpunk, CORTEX, webkamera, sanntid, javascript, biometri, face-api.js, Gemini, Imagen, json, chatbot, api key, tolerance, executive order, EO">
    <meta name="author" content="Gemini AI">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js"></script>

    <style>
        :root {
            --primary-color: #00ffcc;
            --secondary-color: #ff00ff;
            --background-color: #0a0c10;
            --text-color: #e0e0e0;
            --danger-color: #ff3333;
            --font-family: 'Share Tech Mono', monospace;
        }
        html, body {
            height: 100%;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
        }
        .cyber-shadow { text-shadow: 0 0 5px var(--primary-color); }
        .cyber-shadow-secondary { text-shadow: 0 0 5px var(--secondary-color); }
        .cyber-border { border: 2px solid var(--primary-color); box-shadow: 0 0 15px var(--primary-color), inset 0 0 15px var(--primary-color); }
        .cyber-border-secondary { border: 1px solid var(--secondary-color); box-shadow: 0 0 10px var(--secondary-color); }
        .cyber-button {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--primary-color);
        }
        .cyber-button:hover:not(:disabled) { background-color: var(--primary-color); color: var(--background-color); box-shadow: 0 0 15px var(--primary-color); }
        .cyber-button:disabled { border-color: #555; color: #555; cursor: not-allowed; box-shadow: none; }
        .cyber-button-secondary {
            background-color: transparent;
            border: 2px solid var(--secondary-color);
            color: var(--secondary-color);
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--secondary-color);
        }
        .cyber-button-secondary:hover:not(:disabled) { background-color: var(--secondary-color); color: var(--background-color); box-shadow: 0 0 15px var(--secondary-color); }
        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0) 0, rgba(255,255,255,0.05) 1px, rgba(0,0,0,0.1) 2px);
            pointer-events: none;
            z-index: 1000;
        }
        .spinner {
            width: 48px; height: 48px; border: 5px solid var(--primary-color); border-bottom-color: transparent;
            border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Help Modal Tab Styling */
        .help-tab {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid var(--secondary-color);
            opacity: 0.6;
            transition: all 0.3s;
        }
        .help-tab.active, .help-tab:hover {
            opacity: 1;
            background-color: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 10px var(--secondary-color);
        }
        #night-vision-toggle[data-active="true"] {
            background-color: rgba(0, 255, 204, 0.2);
            box-shadow: 0 0 10px var(--primary-color);
            color: var(--primary-color);
        }
    </style>
</head>
<body class="text-[var(--text-color)] bg-black p-4">

    <div class="container mx-auto flex-col lg:flex-row gap-8 w-full lg:h-full lg:max-h-[95vh] max-w-7xl cyber-border p-4 bg-[rgba(10,12,16,0.8)] backdrop-blur-sm hidden" id="main-container">
        
        <div class="main-content flex-grow flex flex-col min-w-0 flex-[3]">
            <div class="flex justify-between items-center mb-2">
                <h1 class="text-2xl text-[var(--primary-color)] cyber-shadow tracking-[3px]">
                    // CORTEX ANOMALY DETECTION //
                </h1>
                <div id="clock" class="text-lg text-right text-[var(--primary-color)] cyber-shadow"></div>
            </div>
            <div class="video-container relative w-full bg-black cyber-border-secondary aspect-video">
                <video id="video" class="absolute top-0 left-0 w-full h-full object-cover" autoplay muted playsinline></video>
                <canvas id="night-vision-canvas" class="absolute top-0 left-0 w-full h-full hidden" style="z-index: 1;"></canvas>
                <canvas id="overlay" class="absolute top-0 left-0 w-full h-full" style="z-index: 2;"></canvas>
            </div>
            <div id="controls-grid" class="controls grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mt-4">
                <button id="capture-btn" class="cyber-button py-2 uppercase text-sm" disabled>REGISTRER ANSIKT</button>
                <button id="github-sync-btn" class="cyber-button py-2 uppercase text-sm" disabled>üîó SYNK GITHUB</button>
                <button id="save-btn" class="cyber-button py-2 uppercase text-sm" disabled>EKSPORTER DB</button>
                <label for="load-input" class="cyber-button text-center py-2 uppercase text-sm cursor-pointer" id="load-label">IMPORTER DB</label>
                <input type="file" id="load-input" class="hidden" accept=".json">
                <button id="behavior-btn" class="cyber-button py-2 uppercase text-sm" disabled>üïµÔ∏è ANALYSER ADFERD</button>
                <button id="report-btn" class="cyber-button py-2 uppercase text-sm" disabled>‚ú® GENERER RAPPORT</button>
                <button id="summary-btn" class="cyber-button py-2 uppercase text-sm" disabled>üìñ LOGG-SAMMENDRAG</button>
                <button id="save-unknown-btn" class="cyber-button py-2 uppercase text-sm" disabled>‚¨áÔ∏è EKSPORTER UKJENTE</button>
            </div>
             <div class="mt-auto text-center text-xs text-gray-500 pt-4">
                <p>CORTEX v7.0.1 | Operat√∏r: Jon-Arve Constantine Gr√∏nsberg-Ovesen</p>
            </div>
        </div>

        <div class="sidebar w-full lg:w-auto flex-grow-0 lg:flex-grow flex flex-col gap-4 bg-[rgba(0,0,0,0.3)] border border-[var(--primary-color)] p-4 min-w-[250px] flex-[1] lg:overflow-y-auto">
            <div>
                 <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">API N√òKKEL</h2>
                 <div class="flex gap-2">
                    <input type="password" id="api-key-input" placeholder="Lim inn din Google API N√∏kkel" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-1 w-full font-mono text-xs">
                    <button id="save-api-key-btn" class="cyber-button px-2 text-sm">LAGRE</button>
                 </div>
            </div>
            <div>
                 <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">INNSTILLINGER</h2>
                 <label for="tolerance-slider" class="text-sm">Gjenkjenningstoleranse: <span id="tolerance-value">0.6</span></label>
                 <input type="range" id="tolerance-slider" min="0.3" max="0.7" value="0.6" step="0.05" class="w-full mt-1">
                 <label for="interval-input" class="text-sm mt-2 block">Sekvens-intervall (ms):</label>
                 <input type="number" id="interval-input" value="500" min="100" max="2000" step="100" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-1 w-full font-mono text-xs mt-1">
                 <div id="camera-selector-container" class="hidden mt-2">
                     <label for="camera-select" class="text-sm block">KAMERAVALGSYSTEM:</label>
                     <select id="camera-select" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-1 w-full font-mono text-xs mt-1"></select>
                 </div>
                 <div class="mt-2 flex items-center justify-between">
                     <label for="night-vision-toggle" class="text-sm">M√òRKESYN:</label>
                     <button id="night-vision-toggle" class="cyber-button px-3 py-1 text-xs" data-active="false">AV</button>
                 </div>
            </div>
            <div>
                 <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">AI-PROTOKOLLER</h2>
                 <div class="grid grid-cols-2 lg:grid-cols-2 gap-2">
                     <button id="gabriel-btn" class="cyber-button py-2 uppercase text-xs">GABRIEL</button>
                     <button id="rafael-btn" class="cyber-button py-2 uppercase text-xs" disabled>RAFAEL</button>
                     <button id="metatron-btn" class="cyber-button py-2 uppercase text-xs" disabled>METATRON</button>
                     <button id="uriel-btn" class="cyber-button py-2 uppercase text-xs" disabled>URIEL</button>
                     <button id="sandalphon-btn" class="cyber-button col-span-2 lg:col-span-2 py-2 uppercase text-xs" disabled>SANDALPHON</button>
                 </div>
            </div>
            <div>
                 <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">HJELP & INFO</h2>
                 <div class="grid grid-cols-2 gap-2">
                    <button id="help-btn" class="cyber-button w-full py-2 uppercase text-sm">HJELPESENTER</button>
                    <button id="eo-btn" class="cyber-button w-full py-2 uppercase text-sm">DIREKTIV 7A</button>
                 </div>
            </div>
            <div>
                <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">KJENTE INDIVIDER</h2>
                <ul id="known-faces-list" class="list-none h-32 overflow-y-auto bg-[rgba(0,0,0,0.5)] p-2 text-sm"></ul>
            </div>
            <div>
                <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">SYSTEMLOGG</h2>
                <ul id="log" class="list-none h-32 overflow-y-auto bg-[rgba(0,0,0,0.5)] p-2 text-xs"></ul>
            </div>
            <div class="flex flex-col flex-grow min-h-0">
                <h2 class="text-lg text-[var(--secondary-color)] cyber-shadow-secondary border-b border-[var(--secondary-color)] pb-2 mb-2">CORTEX ASSISTENT</h2>
                <div id="chat-history" class="flex-grow h-32 overflow-y-auto bg-[rgba(0,0,0,0.5)] p-2 text-xs space-y-2"></div>
                <form id="chat-form" class="flex gap-2 mt-2">
                    <input type="text" id="chat-input" placeholder="Sp√∏r assistenten..." class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-1 w-full font-mono text-xs" disabled>
                    <button id="chat-submit-btn" type="submit" class="cyber-button px-2 text-sm" disabled>SEND</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Modals (full HTML restored) -->
    <div id="loading-message" class="fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-50 flex-col gap-4 text-center">
        <div class="text-3xl text-[var(--primary-color)] cyber-shadow">INITIALISERER AI-KJERNE...</div>
        <div id="loading-status" class="max-w-xs">Venter p√• AI-bibliotek...</div>
    </div>
    <div id="welcome-modal" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-40 p-4">
        <div class="modal text-center max-w-2xl">
             <h1 class="text-4xl text-[var(--primary-color)] cyber-shadow mb-4 tracking-widest">
                Welcome to CORTEX v7.0.1
            </h1>
            <p class="text-lg text-gray-300 mb-8 italic">
                Mission: Delivering AI-powered anomaly detection and biometric security to the next level. Built for executives, operators, and developers who value security, insight, and innovation.
            </p>
            <button id="enter-app-btn" class="cyber-button text-xl uppercase py-3 px-8">Start System</button>
        </div>
    </div>
    <div id="modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4">REGISTRER NYTT INDIVID</h2>
            <p class="mb-4">Skriv inn navn p√• individet:</p>
            <input type="text" id="name-input" placeholder="Navn..." class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-2 w-full mb-4 font-mono">
            <button id="submit-name-btn" class="cyber-button w-full py-2 uppercase">LAGRE</button>
        </div>
    </div>
    <div id="report-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center w-full max-w-2xl max-h-[80vh] flex flex-col">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4">ANALYSERAPPORT</h2>
            <div id="report-content" class="text-left overflow-y-auto flex-grow bg-black/30 p-4 text-sm/relaxed"></div>
            <button id="close-report-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
    <div id="behavior-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40 p-4">
       <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center w-full max-w-2xl max-h-[80vh] flex flex-col">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4">SUBJEKTANALYSE</h2>
            <div id="behavior-content" class="text-left overflow-y-auto flex-grow bg-black/30 p-4 text-sm/relaxed"></div>
            <div id="anomaly-explanation" class="hidden text-left overflow-y-auto flex-grow bg-black/30 p-4 text-sm/relaxed mt-4 border-t-2 border-[var(--danger-color)]"></div>
            <button id="close-behavior-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
    <div id="imagen-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40 p-4">
       <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center w-full max-w-lg max-h-[90vh] flex flex-col">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4">GENERER FANTOMBILDE</h2>
            <p class="mb-2 text-sm">Beskriv subjektet (f.eks. "mann med blondt h√•r, smiler"):</p>
            <input type="text" id="imagen-prompt" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-2 w-full mb-4 font-mono">
            <div id="imagen-display" class="w-full aspect-square bg-black/50 mb-4 flex items-center justify-center border border-dashed border-[var(--primary-color)]">
                <span class="text-gray-500">Bilde vises her</span>
            </div>
            <div class="flex gap-4">
                <button id="generate-imagen-btn" class="cyber-button w-full py-2 uppercase">GENERER</button>
                <button id="close-imagen-btn" class="cyber-button w-full py-2 uppercase">LUKK</button>
            </div>
        </div>
    </div>
    <div id="protocol-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center w-full max-w-2xl max-h-[80vh] flex flex-col">
            <h2 id="protocol-title" class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4"></h2>
            <div id="protocol-content" class="text-left overflow-y-auto flex-grow bg-black/30 p-4 text-sm/relaxed"></div>
            <button id="close-protocol-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
    <div id="summary-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.9)] z-40 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-8 shadow-[0_0_15px_var(--secondary-color)] text-center w-full max-w-3xl max-h-[80vh] flex flex-col">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4">LOGG-SAMMENDRAG</h2>
            <div id="summary-content" class="text-left overflow-y-auto flex-grow bg-black/30 p-4 text-sm/relaxed"></div>
            <button id="close-summary-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
    <div id="metatron-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-50 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--secondary-color)] p-4 sm:p-8 shadow-[0_0_25px_var(--secondary-color)] w-full max-w-4xl max-h-[90vh] flex flex-col">
            <h2 class="text-2xl text-[var(--secondary-color)] cyber-shadow-secondary mb-4 text-center">PROTOKOLL METATRON: PREDIKTIV ANALYSE</h2>
            <div class="flex-grow grid grid-cols-1 md:grid-cols-2 gap-4 min-h-0">
                <div class="flex flex-col gap-4">
                    <h3 class="text-lg text-[var(--primary-color)] cyber-shadow">INNHENTET SEKVENSDATA</h3>
                    <div id="metatron-frames-container" class="grid grid-cols-3 sm:grid-cols-5 gap-2 bg-black/30 p-2 border border-dashed border-[var(--primary-color)]"></div>
                     <div id="metatron-confidence-visualizer" class="w-full">
                        <h3 class="text-lg text-[var(--primary-color)] cyber-shadow mb-2">PREDIKSJONSKONFIDENS</h3>
                        <div class="w-full bg-black/50 border-2 border-[var(--primary-color)] h-8 p-1">
                            <div id="confidence-bar" class="bg-[var(--primary-color)] h-full transition-all duration-1000 ease-out" style="width: 0%;"></div>
                        </div>
                        <p id="confidence-text" class="text-center mt-1 text-lg">0%</p>
                    </div>
                </div>
                <div class="flex flex-col min-h-0">
                    <h3 class="text-lg text-[var(--primary-color)] cyber-shadow">AI PREDIKSJON</h3>
                    <div id="metatron-prediction-content" class="text-left overflow-y-auto flex-grow bg-black/30 p-4 text-base/relaxed mt-2"></div>
                </div>
            </div>
            <button id="close-metatron-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
    <div id="help-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-50 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--primary-color)] p-4 sm:p-6 shadow-[0_0_25px_var(--primary-color)] w-full max-w-4xl max-h-[90vh] flex flex-col">
            <h2 class="text-2xl text-[var(--primary-color)] cyber-shadow mb-4 text-center">CORTEX HJELPESENTER</h2>
            <div class="flex border-b border-[var(--primary-color)] mb-4">
                <button data-tab="howto" class="help-tab flex-1 p-2 uppercase text-sm">Slik Gj√∏r Du</button>
                <button data-tab="wiki" class="help-tab flex-1 p-2 uppercase text-sm">Wiki / Begreper</button>
                <button data-tab="examples" class="help-tab flex-1 p-2 uppercase text-sm">Eksempler</button>
            </div>
            <div class="flex-grow overflow-y-auto p-4 bg-black/30 text-sm/relaxed space-y-4">
                <div id="howto-content" class="help-tab-content space-y-4">
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">1. Aktivere AI-funksjoner</h3>
                        <p>Lim inn din Google AI Studio API-n√∏kkel i feltet "API N√òKKEL" √∏verst i sidepanelet og trykk "LAGRE". Dette aktiverer alle AI-drevne knapper.</p>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">2. Registrere et nytt ansikt</h3>
                        <p>Rett kameraet mot et ansikt og trykk "REGISTRER ANSIKT". Skriv inn et navn i vinduet som dukker opp og trykk "LAGRE". Personen vil n√• gjenkjennes av systemet.</p>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">3. Justere Gjenkjenning</h3>
                        <p>Hvis kjente fjes ikke gjenkjennes, pr√∏v √• √∏ke "Gjenkjenningstoleranse"-verdien i innstillingene. En verdi rundt 0.5-0.6 er vanligvis best.</p>
                    </div>
                     <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">4. Bruke AI-Protokoller</h3>
                        <p>Trykk p√• GABRIEL, RAFAEL, URIEL, SANDALPHON eller METATRON for √• f√• spesialiserte analyser. METATRON gir den dypeste, prediktive analysen av et subjekts intensjon.</p>
                    </div>
                     <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">5. Bytte Kamera</h3>
                        <p>Hvis flere kameraer er tilkoblet, vil en nedtrekksmeny vises under "Innstillinger". Velg et kamera fra listen for √• bytte videokilde umiddelbart.</p>
                    </div>
                </div>
                <div id="wiki-content" class="help-tab-content hidden space-y-4">
                     <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Gjenkjenningstoleranse</h3>
                        <p>Dette er en verdi som bestemmer hvor strengt systemet er n√•r det sammenligner ansikter. En lav verdi (f.eks. 0.4) krever et nesten perfekt treff. En h√∏yere verdi (f.eks. 0.6) er mer tolerant for variasjoner som smil eller ulik belysning.</p>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Protokoll GABRIEL</h3>
                        <p>En AI-drevet beskytter av informasjonsintegritet. Protokollen verifiserer den lagrede ansiktsdatabasen for √• sikre at den er ukorrupt og sikker. Den genererer en sjekksum som fungerer som et digitalt segl.</p>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Protokoll RAFAEL</h3>
                        <p>En AI-drevet beskytter av transport og bevegelse. Protokollen analyserer en sekvens av bilder for √• vurdere flyt, tetthet og unormale bevegelsesm√∏nstre i sanntid.</p>
                    </div>
                     <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Protokoll URIEL</h3>
                        <p>En AI-drevet beskytter av omgivelsene. Protokollen analyserer videostr√∏mmen for avvik i milj√∏et, slik som gjenglemte gjenstander, √•pne d√∏rer eller uvanlige objekter, og gir en risikovurdering.</p>
                    </div>
                     <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Protokoll SANDALPHON</h3>
                        <p>En AI-drevet protokoll for analyse av sosial dynamikk. Sandalphon observerer grupper av individer for √• vurdere deres interaksjoner ‚Äì om de er positive, negative, eller n√∏ytrale ‚Äì og identifiserer potensielt urovekkende gruppedynamikk.</p>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Protokoll METATRON</h3>
                        <p>Den mest avanserte protokollen. METATRON analyserer en bildesekvens for √• forutsi et subjekts sannsynlige neste handling eller intensjon. Den gir en konkret prediksjon og en konfidensscore.</p>
                    </div>
                </div>
                <div id="examples-content" class="help-tab-content hidden space-y-4">
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Gode Prompts for CORTEX Assistent</h3>
                        <ul class="list-disc ml-6">
                            <li>"List alle avvik siste time."</li>
                            <li>"N√•r ble 'Navn Navnesen' sist observert?"</li>
                            <li>"Hvor mange unike, ukjente individer er logget?"</li>
                            <li>"Har det v√¶rt noen systemfeil i dag?"</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-lg text-[var(--secondary-color)]">Gode Beskrivelser for Fantombilde (Imagen)</h3>
                        <p>V√¶r s√• spesifikk som mulig. Bruk adjektiver.</p>
                        <ul class="list-disc ml-6">
                            <li>"Fotorealistisk portrett av en eldre mann med gr√•tt, kort h√•r, rynker og et alvorlig uttrykk."</li>
                            <li>"En ung kvinne med langt, r√∏dt h√•r, bl√• √∏yne og fregner, smiler."</li>
                            <li>"Mann i 30-√•rene med m√∏rkt skjegg, briller og en n√∏ytral ansiktsmine."</li>
                        </ul>
                    </div>
                </div>
            </div>
            <button id="close-help-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>
     <div id="eo-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-50 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--primary-color)] p-4 sm:p-6 shadow-[0_0_25px_var(--primary-color)] w-full max-w-2xl max-h-[90vh] flex flex-col">
            <h2 class="text-2xl text-[var(--primary-color)] cyber-shadow mb-4 text-center">EXECUTIVE ORDER // DIREKTIV 7A</h2>
            <div class="flex-grow overflow-y-auto p-4 bg-black/30 text-sm/relaxed space-y-4">
                <div>
                    <h3 class="text-lg text-[var(--secondary-color)]">PREAMBEL</h3>
                    <p>Dette direktivet etablerer de operative og etiske rammene for CORTEX-systemet. Systemets form√•l er √• fungere som et avansert beslutningsst√∏tteverkt√∏y for sikkerhetspersonell, med m√•l om √• √∏ke effektivitet, innsikt og proaktiv respons.</p>
                </div>
                <div>
                    <h3 class="text-lg text-[var(--secondary-color)]">MANDAT 1: PROAKTIV SIKKERHET</h3>
                    <p>CORTEX skal prioritere identifisering og analyse av potensielle trusler *f√∏r* de eskalerer. Ved hjelp av prediktive analyser (METATRON) og sanntidsvurderinger (RAFAEL, URIEL, SANDALPHON), skal systemet gi operat√∏ren tidlig varsling om avvikende adferd, m√∏nstre og milj√∏farer.</p>
                </div>
                <div>
                    <h3 class="text-lg text-[var(--secondary-color)]">MANDAT 2: INFORMASJONSINTEGRITET</h3>
                    <p>All data samlet og behandlet av CORTEX er en kritisk ressurs. Systemet skal sikre dataintegritet gjennom verifiserbare mekanismer (GABRIEL). All datah√•ndtering skal v√¶re sporbar og sikker.</p>
                </div>
                <div>
                    <h3 class="text-lg text-[var(--secondary-color)]">MANDAT 3: OPERAT√òR-MYNDIGGJ√òRING</h3>
                    <p>AI-en er et verkt√∏y for √• forsterke menneskelig intuisjon og ekspertise, ikke erstatte den. Systemet skal levere klar, konsis og handlingsrettet informasjon som gir operat√∏ren full kontroll og et solid grunnlag for √• ta avgj√∏rende beslutninger. Mennesket har alltid den endelige autoriteten.</p>
                </div>
            </div>
            <button id="close-eo-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>

    <!-- GitHub Authentication Modal -->
    <div id="github-auth-modal-backdrop" class="hidden fixed inset-0 flex justify-center items-center bg-[rgba(0,0,0,0.95)] z-50 p-4">
        <div class="modal bg-[var(--background-color)] border-2 border-[var(--primary-color)] p-4 sm:p-6 shadow-[0_0_25px_var(--primary-color)] w-full max-w-lg max-h-[90vh] flex flex-col">
            <h2 class="text-2xl text-[var(--primary-color)] cyber-shadow mb-4 text-center">GITHUB INTEGRASJON</h2>
            
            <div id="github-login-section" class="space-y-4">
                <p class="text-center text-sm text-gray-300">Koble til GitHub for √• lagre data i skyen</p>
                
                <div class="space-y-2">
                    <label class="block text-sm text-[var(--primary-color)]">GitHub Personal Access Token:</label>
                    <input type="password" id="github-token-input" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-2 w-full font-mono text-sm" placeholder="ghp_...">
                    <p class="text-xs text-gray-400">Opprett en token med 'repo' tillatelser p√• github.com/settings/tokens</p>
                </div>
                
                <button id="github-login-btn" class="cyber-button w-full py-2 uppercase">KOBLE TIL GITHUB</button>
            </div>

            <div id="github-connected-section" class="hidden space-y-4">
                <div class="text-center space-y-2">
                    <p class="text-sm text-[var(--primary-color)]">‚úì Koblet til som: <span id="github-username" class="font-bold"></span></p>
                    <p class="text-xs text-gray-400">Repository: <span id="github-repo" class="text-[var(--primary-color)]"></span></p>
                </div>
                
                <div class="space-y-2">
                    <label class="block text-sm text-[var(--primary-color)]">Velg eller opprett repository:</label>
                    <input type="text" id="github-repo-input" class="bg-[#222] border border-[var(--primary-color)] text-[var(--primary-color)] p-2 w-full font-mono text-sm" placeholder="cortex-database">
                    <p class="text-xs text-gray-400">Vil opprette repository hvis det ikke finnes</p>
                </div>
                
                <button id="github-setup-repo-btn" class="cyber-button w-full py-2 uppercase">SETT OPP REPOSITORY</button>
                <button id="github-disconnect-btn" class="cyber-button-secondary w-full py-2 uppercase">KOBLE FRA</button>
            </div>

            <button id="close-github-auth-btn" class="cyber-button w-full py-2 uppercase mt-4">LUKK</button>
        </div>
    </div>

    <!-- GitHub Sync Status -->
    <div id="github-status" class="hidden fixed top-4 right-4 bg-[var(--background-color)] border border-[var(--primary-color)] p-2 text-xs z-30">
        <span id="github-status-text">GitHub: Ikke tilkoblet</span>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize basic UI elements that don't depend on face-api
            const nightVisionToggle = document.getElementById('night-vision-toggle');
            const nightVisionCanvas = document.getElementById('night-vision-canvas');
            const video = document.getElementById('video');
            let nightVisionActive = false;
            let nightVisionInterval;

            // Night vision functionality (independent of face-api)
            function toggleNightVision() {
                nightVisionActive = !nightVisionActive;
                
                if (nightVisionActive) {
                    nightVisionToggle.textContent = 'P√Ö';
                    nightVisionToggle.dataset.active = 'true';
                    nightVisionCanvas.classList.remove('hidden');
                    video.style.display = 'none';
                    startNightVisionRendering();
                    console.log('M√∏rkesyn aktivert');
                } else {
                    nightVisionToggle.textContent = 'AV';
                    nightVisionToggle.dataset.active = 'false';
                    nightVisionCanvas.classList.add('hidden');
                    video.style.display = 'block';
                    stopNightVisionRendering();
                    console.log('M√∏rkesyn deaktivert');
                }
            }

            function startNightVisionRendering() {
                const ctx = nightVisionCanvas.getContext('2d');
                
                function renderNightVision() {
                    if (!nightVisionActive || video.paused || video.ended || video.videoWidth === 0) return;
                    
                    // Set canvas size to match video
                    nightVisionCanvas.width = video.videoWidth;
                    nightVisionCanvas.height = video.videoHeight;
                    
                    // Draw video frame to canvas
                    ctx.drawImage(video, 0, 0, nightVisionCanvas.width, nightVisionCanvas.height);
                    
                    // Apply night vision filter (green tint)
                    const imageData = ctx.getImageData(0, 0, nightVisionCanvas.width, nightVisionCanvas.height);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Convert to grayscale
                        const gray = r * 0.299 + g * 0.587 + b * 0.114;
                        
                        // Apply green night vision effect
                        data[i] = Math.min(255, gray * 0.2);     // Red - reduced
                        data[i + 1] = Math.min(255, gray * 1.5); // Green - enhanced
                        data[i + 2] = Math.min(255, gray * 0.2); // Blue - reduced
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                }
                
                nightVisionInterval = setInterval(renderNightVision, 33); // ~30 FPS
            }

            function stopNightVisionRendering() {
                if (nightVisionInterval) {
                    clearInterval(nightVisionInterval);
                    nightVisionInterval = null;
                }
            }

            // Add night vision event listener
            if (nightVisionToggle) {
                nightVisionToggle.addEventListener('click', toggleNightVision);
            }

            // Initialize night vision canvas size when video loads
            if (video) {
                video.addEventListener('loadedmetadata', () => {
                    nightVisionCanvas.width = video.videoWidth;
                    nightVisionCanvas.height = video.videoHeight;
                });
            }

            // Check if face-api is available for face recognition features
            if (typeof faceapi === 'undefined') {
                document.getElementById('loading-status').innerText = "KRITISK FEIL: AI-biblioteket (face-api.js) kunne ikke lastes.";
                return;
            }

            // --- All element references consolidated ---
            const overlay = document.getElementById('overlay');
            const captureBtn = document.getElementById('capture-btn');
            const saveBtn = document.getElementById('save-btn');
            const loadInput = document.getElementById('load-input');
            const reportBtn = document.getElementById('report-btn');
            const behaviorBtn = document.getElementById('behavior-btn');
            const saveUnknownBtn = document.getElementById('save-unknown-btn');
            const summaryBtn = document.getElementById('summary-btn');
            const knownFacesList = document.getElementById('known-faces-list');
            const logList = document.getElementById('log');
            const loadingMessage = document.getElementById('loading-message');
            const controlsGrid = document.getElementById('controls-grid');
            const apiKeyInput = document.getElementById('api-key-input');
            const saveApiKeyBtn = document.getElementById('save-api-key-btn');
            const chatHistoryEl = document.getElementById('chat-history');
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const chatSubmitBtn = document.getElementById('chat-submit-btn');
            const modalBackdrop = document.getElementById('modal-backdrop');
            const nameInput = document.getElementById('name-input');
            const submitNameBtn = document.getElementById('submit-name-btn');
            const reportModal = document.getElementById('report-modal-backdrop');
            const reportContent = document.getElementById('report-content');
            const closeReportBtn = document.getElementById('close-report-btn');
            const behaviorModal = document.getElementById('behavior-modal-backdrop');
            const behaviorContent = document.getElementById('behavior-content');
            const closeBehaviorBtn = document.getElementById('close-behavior-btn');
            const anomalyExplanationEl = document.getElementById('anomaly-explanation');
            const imagenModal = document.getElementById('imagen-modal-backdrop');
            const imagenPrompt = document.getElementById('imagen-prompt');
            const imagenDisplay = document.getElementById('imagen-display');
            const generateImagenBtn = document.getElementById('generate-imagen-btn');
            const closeImagenBtn = document.getElementById('close-imagen-btn');
            const protocolModal = document.getElementById('protocol-modal-backdrop');
            const protocolTitle = document.getElementById('protocol-title');
            const protocolContent = document.getElementById('protocol-content');
            const closeProtocolBtn = document.getElementById('close-protocol-btn');
            const gabrielBtn = document.getElementById('gabriel-btn');
            const rafaelBtn = document.getElementById('rafael-btn');
            const metatronBtn = document.getElementById('metatron-btn');
            const urielBtn = document.getElementById('uriel-btn');
            const sandalphonBtn = document.getElementById('sandalphon-btn');
            const toleranceSlider = document.getElementById('tolerance-slider');
            const toleranceValue = document.getElementById('tolerance-value');
            const intervalInput = document.getElementById('interval-input');
            const summaryModal = document.getElementById('summary-modal-backdrop');
            const summaryContent = document.getElementById('summary-content');
            const closeSummaryBtn = document.getElementById('close-summary-btn');
            const metatronModal = document.getElementById('metatron-modal-backdrop');
            const metatronFramesContainer = document.getElementById('metatron-frames-container');
            const metatronPredictionContent = document.getElementById('metatron-prediction-content');
            const confidenceBar = document.getElementById('confidence-bar');
            const confidenceText = document.getElementById('confidence-text');
            const closeMetatronBtn = document.getElementById('close-metatron-btn');
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal-backdrop');
            const closeHelpBtn = document.getElementById('close-help-btn');
            const helpTabs = helpModal.querySelectorAll('.help-tab');
            const helpTabContents = helpModal.querySelectorAll('.help-tab-content');
            const cameraSelect = document.getElementById('camera-select');
            const cameraSelectorContainer = document.getElementById('camera-selector-container');
            const mainContainer = document.getElementById('main-container');
            const welcomeModal = document.getElementById('welcome-modal');
            const enterAppBtn = document.getElementById('enter-app-btn');
            const eoBtn = document.getElementById('eo-btn');
            const eoModal = document.getElementById('eo-modal-backdrop');
            const closeEoBtn = document.getElementById('close-eo-btn');
            const clockEl = document.getElementById('clock');
            
            // GitHub elements
            const githubSyncBtn = document.getElementById('github-sync-btn');
            const githubAuthModal = document.getElementById('github-auth-modal-backdrop');
            const githubTokenInput = document.getElementById('github-token-input');
            const githubLoginBtn = document.getElementById('github-login-btn');
            const githubLoginSection = document.getElementById('github-login-section');
            const githubConnectedSection = document.getElementById('github-connected-section');
            const githubUsername = document.getElementById('github-username');
            const githubRepo = document.getElementById('github-repo');
            const githubRepoInput = document.getElementById('github-repo-input');
            const githubSetupRepoBtn = document.getElementById('github-setup-repo-btn');
            const githubDisconnectBtn = document.getElementById('github-disconnect-btn');
            const closeGithubAuthBtn = document.getElementById('close-github-auth-btn');
            const githubStatus = document.getElementById('github-status');
            const githubStatusText = document.getElementById('github-status-text');
            
            // State variables
            let userApiKey = ''; 
            let knownFaceDescriptors = [];
            let unknownFaceDescriptors = [];
            let faceMatcher;
            let lastCapturedDescriptor = null;
            let detectionInterval;
            let imagenBtn = null; 
            let currentStream;

            // GitHub state
            let githubToken = '';
            let githubUser = '';
            let githubRepoName = '';
            let isGithubConnected = false;

            // --- All functions are restored here... ---
            
            function addLog(message, type = 'system') {
                const li = document.createElement('li');
                const timestamp = new Date().toLocaleString('sv-SE');
                li.textContent = `[${timestamp}] ${message}`;
                li.className = type;
                logList.prepend(li);
                if (logList.children.length > 100) logList.removeChild(logList.lastChild);
            }

            function updateClock() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('no-NO');
                const dateString = now.toLocaleDateString('no-NO', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                if (clockEl) {
                    clockEl.innerHTML = `${dateString} <br> ${timeString}`;
                }
            }
            
            async function startStream(deviceId = null) {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined
                    }
                };
                try {
                    addLog(`Fors√∏ker √• starte kamera: ${deviceId || 'default'}...`, 'system');
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    await video.play(); // Explicitly play the new stream
                    currentStream = stream;
                    const trackLabel = stream.getVideoTracks()[0].label;
                    addLog(`Kamerastr√∏m aktiv: ${trackLabel || 'Ukjent kamera'}`, 'known');
                } catch (err) {
                     addLog(`FEIL ved start av kamera: ${err.message}`, 'anomaly');
                }
            }
            
            async function getCameras() {
                try {
                    await navigator.mediaDevices.getUserMedia({video: true});
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length > 1) {
                        cameraSelectorContainer.classList.remove('hidden');
                        cameraSelect.innerHTML = '';
                        videoDevices.forEach((device, index) => {
                            const option = document.createElement('option');
                            option.value = device.deviceId;
                            option.text = device.label || `Kamera ${index + 1}`;
                            cameraSelect.appendChild(option);
                        });
                    }
                } catch(e) {
                    addLog("Kunne ikke hente kameraliste. Mangler tillatelse?", "anomaly");
                }
            }

            // === GitHub Integration Functions ===
            
            function initializeGithubToken() {
                // Try to restore GitHub token from sessionStorage
                const savedToken = sessionStorage.getItem('cortex_github_token');
                const savedUser = sessionStorage.getItem('cortex_github_user');
                const savedRepo = sessionStorage.getItem('cortex_github_repo');
                
                if (savedToken && savedUser) {
                    githubToken = savedToken;
                    githubUser = savedUser;
                    githubRepoName = savedRepo || '';
                    isGithubConnected = true;
                    updateGithubStatus();
                    githubSyncBtn.disabled = false;
                }
            }

            function updateGithubStatus() {
                if (isGithubConnected) {
                    githubStatus.classList.remove('hidden');
                    githubStatusText.textContent = `GitHub: ${githubUser}${githubRepoName ? ` / ${githubRepoName}` : ''}`;
                    githubUsername.textContent = githubUser;
                    githubRepo.textContent = githubRepoName || 'Ikke satt';
                    githubLoginSection.classList.add('hidden');
                    githubConnectedSection.classList.remove('hidden');
                } else {
                    githubStatus.classList.add('hidden');
                    githubStatusText.textContent = 'GitHub: Ikke tilkoblet';
                    githubLoginSection.classList.remove('hidden');
                    githubConnectedSection.classList.add('hidden');
                }
            }

            async function authenticateGithub() {
                const token = githubTokenInput.value.trim();
                if (!token) {
                    addLog('Vennligst angi en GitHub Personal Access Token.', 'anomaly');
                    return;
                }

                try {
                    addLog('Autentiserer med GitHub...', 'system');
                    const response = await fetch('https://api.github.com/user', {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (response.ok) {
                        const user = await response.json();
                        githubToken = token;
                        githubUser = user.login;
                        isGithubConnected = true;
                        
                        // Store securely in sessionStorage (not localStorage for security)
                        sessionStorage.setItem('cortex_github_token', token);
                        sessionStorage.setItem('cortex_github_user', user.login);
                        
                        updateGithubStatus();
                        githubSyncBtn.disabled = false;
                        addLog(`GitHub autentisering vellykket: ${user.login}`, 'known');
                        githubTokenInput.value = '';
                        
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    addLog(`GitHub autentisering feilet: ${error.message}`, 'anomaly');
                    githubTokenInput.value = '';
                }
            }

            async function setupGithubRepository() {
                const repoName = githubRepoInput.value.trim() || 'cortex-database';
                
                try {
                    addLog(`Setter opp repository: ${repoName}...`, 'system');
                    
                    // First check if repo exists
                    let response = await fetch(`https://api.github.com/repos/${githubUser}/${repoName}`, {
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (response.status === 404) {
                        // Repository doesn't exist, create it
                        response = await fetch('https://api.github.com/user/repos', {
                            method: 'POST',
                            headers: {
                                'Authorization': `token ${githubToken}`,
                                'Accept': 'application/vnd.github.v3+json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                name: repoName,
                                description: 'CORTEX Anomaly Detection Database',
                                private: true,
                                auto_init: true
                            })
                        });
                        
                        if (response.ok) {
                            addLog(`Repository '${repoName}' opprettet.`, 'known');
                        } else {
                            throw new Error(`Kunne ikke opprette repository: ${response.statusText}`);
                        }
                    } else if (response.ok) {
                        addLog(`Repository '${repoName}' funnet.`, 'known');
                    } else {
                        throw new Error(`Repository sjekk feilet: ${response.statusText}`);
                    }

                    githubRepoName = repoName;
                    sessionStorage.setItem('cortex_github_repo', repoName);
                    updateGithubStatus();
                    
                    // Initialize repository structure
                    await initializeRepoStructure();
                    
                } catch (error) {
                    addLog(`Repository oppsett feilet: ${error.message}`, 'anomaly');
                }
            }

            async function initializeRepoStructure() {
                const files = [
                    { path: 'data/known_faces.json', content: '[]' },
                    { path: 'data/unknown_faces_cache.json', content: '[]' },
                    { path: 'settings/config.json', content: '{"tolerance": 0.6}' },
                    { path: 'logs/README.md', content: '# CORTEX Logs\n\nDette biblioteket inneholder systemlogger fra CORTEX.' }
                ];

                for (const file of files) {
                    try {
                        // Check if file exists
                        const checkResponse = await fetch(`https://api.github.com/repos/${githubUser}/${githubRepoName}/contents/${file.path}`, {
                            headers: {
                                'Authorization': `token ${githubToken}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });

                        if (checkResponse.status === 404) {
                            // File doesn't exist, create it
                            await fetch(`https://api.github.com/repos/${githubUser}/${githubRepoName}/contents/${file.path}`, {
                                method: 'PUT',
                                headers: {
                                    'Authorization': `token ${githubToken}`,
                                    'Accept': 'application/vnd.github.v3+json',
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: `CORTEX: Initialiserte ${file.path}`,
                                    content: btoa(file.content)
                                })
                            });
                        }
                    } catch (error) {
                        console.warn(`Kunne ikke initialisere ${file.path}:`, error);
                    }
                }
                
                addLog('Repository struktur initialisert.', 'known');
            }

            async function syncToGithub() {
                if (!isGithubConnected || !githubRepoName) {
                    githubAuthModal.classList.remove('hidden');
                    return;
                }

                try {
                    addLog('Synkroniserer til GitHub...', 'system');
                    
                    // Sync known faces
                    const knownFacesData = JSON.stringify(knownFaceDescriptors.map(fd => fd.toJSON()), null, 2);
                    await updateGithubFile('data/known_faces.json', knownFacesData, 'CORTEX: Oppdaterte kjente ansikter');
                    
                    // Sync unknown faces if any
                    if (unknownFaceDescriptors.length > 0) {
                        const unknownFacesData = JSON.stringify(unknownFaceDescriptors.map(fd => fd.toJSON()), null, 2);
                        await updateGithubFile('data/unknown_faces_cache.json', unknownFacesData, 'CORTEX: Oppdaterte ukjente ansikter');
                    }
                    
                    // Sync current config
                    const config = {
                        tolerance: parseFloat(toleranceSlider.value),
                        lastSync: new Date().toISOString()
                    };
                    await updateGithubFile('settings/config.json', JSON.stringify(config, null, 2), 'CORTEX: Oppdaterte konfigurasjon');
                    
                    addLog('GitHub synkronisering fullf√∏rt.', 'known');
                    
                } catch (error) {
                    addLog(`GitHub synkronisering feilet: ${error.message}`, 'anomaly');
                }
            }

            async function updateGithubFile(path, content, message) {
                // Get current file SHA if it exists
                let sha = null;
                try {
                    const response = await fetch(`https://api.github.com/repos/${githubUser}/${githubRepoName}/contents/${path}`, {
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (response.ok) {
                        const fileData = await response.json();
                        sha = fileData.sha;
                    }
                } catch (error) {
                    // File doesn't exist, which is fine
                }

                // Update or create file
                const body = {
                    message: message,
                    content: btoa(content)
                };
                
                if (sha) {
                    body.sha = sha;
                }

                const response = await fetch(`https://api.github.com/repos/${githubUser}/${githubRepoName}/contents/${path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    throw new Error(`Failed to update ${path}: ${response.statusText}`);
                }
            }

            function disconnectGithub() {
                githubToken = '';
                githubUser = '';
                githubRepoName = '';
                isGithubConnected = false;
                
                sessionStorage.removeItem('cortex_github_token');
                sessionStorage.removeItem('cortex_github_user');
                sessionStorage.removeItem('cortex_github_repo');
                
                updateGithubStatus();
                githubSyncBtn.disabled = true;
                githubTokenInput.value = '';
                githubRepoInput.value = '';
                
                addLog('GitHub forbindelse koblet fra.', 'system');
            }

            async function initialize() {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';
                try {
                    loadingMessage.children[1].textContent = 'Laster inn deteksjonsmodeller...';
                    await faceapi.nets.tinyFaceDetector.load(MODEL_URL);
                    await faceapi.nets.faceLandmark68Net.load(MODEL_URL);
                    await faceapi.nets.faceRecognitionNet.load(MODEL_URL);
                    addLog('AI-modeller er klare.', 'known');
                    addLog('Vennligst legg inn en Google API-n√∏kkel for √• aktivere AI-funksjoner.', 'system');
                    loadingMessage.classList.add('hidden');
                    welcomeModal.classList.remove('hidden');
                } catch (err) {
                    addLog(`SYSTEMFEIL: Kunne ikke initialisere. ${err.name}`, 'anomaly');
                }
            }
            
            async function startApp() {
                welcomeModal.classList.add('hidden');
                mainContainer.classList.remove('hidden');
                mainContainer.classList.add('flex');
                await getCameras();
                await startStream();
                captureBtn.disabled = false;
                updateClock();
                setInterval(updateClock, 1000);
                
                // Initialize GitHub integration
                initializeGithubToken();
            }

            function checkApiKey() {
                if (!userApiKey) {
                    addLog('API N√òKKEL MANGLER. Skriv inn en n√∏kkel for √• bruke denne funksjonen.', 'anomaly');
                    return false;
                }
                return true;
            }

            const createLoader = (text = 'Prosesserer...') => `<div class="flex flex-col items-center justify-center h-full"><div class="spinner"></div><p class="mt-4">${text}</p></div>`;
            
            async function callGeminiAPI(prompt, images = [], schema = null) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${userApiKey}`;
                const parts = [{ text: prompt }];
                images.forEach(imgData => {
                    if (imgData) {
                        parts.push({ inline_data: { mime_type: "image/jpeg", data: imgData } });
                    }
                });
                const payload = { contents: [{ parts }] };
                if (schema) payload.generationConfig = { response_mime_type: "application/json", response_schema: schema };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API-kall feilet: ${response.status} ${await response.text()}`);
                const result = await response.json();
                if (result.candidates?.[0]?.content.parts[0].text) {
                    const responseText = result.candidates[0].content.parts[0].text;
                    if (schema) { try { return JSON.parse(responseText); } catch (e) { throw new Error("Feil ved parsing av JSON-svar fra AI."); } }
                    return responseText;
                } else { throw new Error("Fikk tomt eller uventet svar fra AI."); }
            }
            
            async function captureFrameSequence(count = 3, delay = 500) {
                const frames = [];
                for (let i = 0; i < count; i++) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = video.videoWidth;
                    tempCanvas.height = video.videoHeight;
                    tempCanvas.getContext('2d').drawImage(video, 0, 0);
                    frames.push(tempCanvas.toDataURL('image/jpeg').split(',')[1]);
                    if (i < count - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                return frames;
            }
            
            async function generateLogSummary() {
                 if (!checkApiKey()) return;
                if (logList.children.length === 0) {
                    addLog("Loggen er tom. Ingen data √• oppsummere.", "anomaly");
                    return;
                }
                summaryContent.innerHTML = createLoader('Analyserer full logg...');
                summaryModal.classList.remove('hidden');
                const fullLog = Array.from(logList.children).map(li => li.textContent).reverse().join('\n');
                const prompt = `Du er en AI-analytiker for CORTEX-sikkerhetssystemet. Du har f√•tt en komplett systemlogg for en vaktperiode. Din oppgave er √• generere et detaljert sammendrag.
                Loggdata:\n---\n${fullLog}\n---\nAnalyser loggen og produser et sammendrag med f√∏lgende seksjoner, formatert med Markdown:\n1.  **Hovedsammendrag:** Et kort avsnitt som oppsummerer den generelle aktiviteten.\n2.  **Signifikante Hendelser:** En punktliste over de mest betydningsfulle hendelsene (f.eks. f√∏rste gang et nytt ukjent fjes ble sett, kritiske systemfeil, aktivering av AI-protokoller).\n3.  **Trender og M√∏nstre:** Identifiser eventuelle trender, som gjentatte deteksjoner av samme ukjente individ p√• ulike tidspunkter, eller hyppige systemfeil.\n4.  **Konklusjon:** En avsluttende setning om vaktperiodens status (f.eks., "Rolig periode med f√• avvik", "Aktiv periode med flere ukjente individer som krever oppf√∏lging").`;
                try {
                    const responseText = await callGeminiAPI(prompt, []);
                    summaryContent.innerHTML = responseText.replace(/# (.+)/g, '<h3>$1</h3>').replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li class="ml-4 list-disc">$1</li>').replace(/(\n)/g, '<br>');
                } catch (error) {
                    summaryContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under generering av logg-sammendrag: ${error.message}</p>`;
                }
            }
            
            async function generateAndDisplayReport() {
                if (!checkApiKey()) return;
                reportContent.innerHTML = createLoader();
                reportModal.classList.remove('hidden');
                const prompt = `Du er en sikkerhetsanalytiker for CORTEX-systemet. Skriv en kort, profesjonell skiftrapport basert p√• f√∏lgende data. Formater svaret med Markdown. **N√•v√¶rende status:** - Antall kjente individer: ${knownFaceDescriptors.length}. - Antall unike ukjente individer fanget: ${unknownFaceDescriptors.length}. **Siste 10 logghendelser:** ${Array.from(logList.querySelectorAll('li')).slice(0, 10).map(li => li.textContent).join('\n')}. **Din oppgave:** 1. Start med overskriften "Skiftrapport". 2. Oppsummer aktiviteten. 3. Nevn om ukjente individer er observert. 4. Avslutt med en statusvurdering.`;
                try {
                    const responseText = await callGeminiAPI(prompt, []);
                    reportContent.innerHTML = responseText.replace(/# (.+)/g, '<h3>$1</h3>').replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li>$1</li>').replace(/(\n)/g, '<br>');
                } catch (error) {
                    reportContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL: Kunne ikke koble til Gemini. <br><br>${error.message}</p>`;
                }
            }

            async function getAnomalyExplanation(analysisData) {
                anomalyExplanationEl.innerHTML = createLoader('Henter risikovurdering...');
                anomalyExplanationEl.classList.remove('hidden');
                const prompt = `En CORTEX-sikkerhetsoperat√∏r har mottatt f√∏lgende analyse av et **ukjent** subjekt: Vurdering: ${analysisData.assessment}, Emosjonell tilstand: ${analysisData.emotion}. \n\nDin oppgave:\n1. Skriv en kort, en-linjers risikovurdering.\n2. Gi en punktliste med 2-3 konkrete, anbefalte handlinger for operat√∏ren.\nStart svaret ditt med overskriften "**RISIKOVURDERING OG ANBEFALING**".`;
                try {
                    const responseText = await callGeminiAPI(prompt, []);
                    anomalyExplanationEl.innerHTML = responseText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li class="ml-4 list-disc">$1</li>').replace(/(\n)/g, '<br>');
                } catch (error) {
                    anomalyExplanationEl.innerHTML = `<p class="text-[var(--danger-color)]">Kunne ikke hente anbefalinger: ${error.message}</p>`;
                }
            }

            async function analyzeBehavior() {
                if (!checkApiKey()) return;
                
                behaviorContent.innerHTML = createLoader();
                anomalyExplanationEl.classList.add('hidden');
                anomalyExplanationEl.innerHTML = '';
                behaviorModal.classList.remove('hidden');
                toggleImagenButton(false);
                addLog('Starter avansert subjektanalyse...', 'system');
                
                const detectionWithDescriptor = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();

                if (!detectionWithDescriptor) {
                    behaviorContent.innerHTML = `<p class="text-[var(--danger-color)]">Ingen subjekt funnet for analyse.</p>`;
                    return addLog('Analyse feilet: Ingen subjekt i sikte.', 'anomaly');
                }
                
                let isKnown = false;
                if (faceMatcher) {
                    const bestMatch = faceMatcher.findBestMatch(detectionWithDescriptor.descriptor);
                    if (bestMatch.label !== 'unknown') isKnown = true;
                }
                
                if (!isKnown) toggleImagenButton(true);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                tempCanvas.getContext('2d').drawImage(video, 0, 0);
                const base64ImageData = tempCanvas.toDataURL('image/jpeg').split(',')[1];
                
                const prompt = `Analyser bildet av personen og fyll ut JSON-objektet med din vurdering.`;
                const schema = { type: "OBJECT", properties: { emotion: { type: "STRING" }, confidence: { type: "NUMBER" }, attire_color: { type: "STRING" }, held_objects: { type: "ARRAY", items: { type: "STRING" } }, assessment: { type: "STRING" }}, required: ["emotion", "confidence", "attire_color", "held_objects", "assessment"] };

                try {
                    const data = await callGeminiAPI(prompt, [base64ImageData], schema);
                    let objectsList = data.held_objects.length > 0 ? data.held_objects.join(', ') : 'Ingen';
                    behaviorContent.innerHTML = `<ul class="text-left space-y-2"><li><strong>Vurdering:</strong> <span class="text-[var(--primary-color)]">${data.assessment || 'N/A'}</span></li><li><strong>Emosjonell tilstand:</strong> ${data.emotion || 'N/A'} (Konfidens: ${Math.round((data.confidence || 0) * 100)}%)</li><li><strong>Farge p√• antrekk:</strong> ${data.attire_color || 'N/A'}</li><li><strong>Objekter i h√•nd:</strong> ${objectsList}</li></ul>`;
                    addLog('Subjektanalyse (JSON) fullf√∏rt.', 'known');

                    const riskKeywords = ['AVVIK', 'STRESS', 'SINT', 'REDD', 'FRYKT'];
                    const isRisky = riskKeywords.some(keyword => data.assessment.toUpperCase().includes(keyword));
                    if (!isKnown && isRisky) {
                        addLog('Avvik detektert p√• ukjent subjekt. Henter anbefalinger...', 'anomaly');
                        getAnomalyExplanation(data);
                    }

                } catch (error) {
                    behaviorContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under JSON-subjektanalyse. <br><br>${error.message}</p>`;
                    addLog('Subjektanalyse (JSON) feilet kritisk.', 'anomaly');
                }
            }
            
            function toggleImagenButton(show) {
                 if (imagenBtn) {
                    imagenBtn.remove();
                    imagenBtn = null;
                }
               if (show && userApiKey) {
                   imagenBtn = document.createElement('button');
                   imagenBtn.id = 'generate-sketch-btn';
                   imagenBtn.className = 'cyber-button py-2 uppercase text-sm';
                   imagenBtn.innerHTML = 'üñºÔ∏è GENERER FANTOMBILDE';
                   imagenBtn.onclick = () => imagenModal.classList.remove('hidden');
                   controlsGrid.appendChild(imagenBtn);
               }
           }
            
            async function callImagenAPI(prompt) {
                if (!checkApiKey()) return;
                addLog('Kaller p√• Imagen for bildegenerering...', 'system');
                imagenDisplay.innerHTML = createLoader('Genererer bilde...');
                const payload = { instances: [{ prompt: `fotorealistisk portrett av en person, ${prompt}` }], parameters: { "sampleCount": 1 } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${userApiKey}`;
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`Imagen API feilet: ${response.status} ${await response.text()}`);
                    const result = await response.json();
                    if (result.predictions?.[0]?.bytesBase64Encoded) {
                        const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        imagenDisplay.innerHTML = `<img src="${imageUrl}" class="w-full h-full object-contain">`;
                        addLog('Fantombilde generert.', 'known');
                    } else { throw new Error("Uventet svarformat fra Imagen."); }
                } catch(error) {
                    addLog(`FEIL ved bildegenerering: ${error.message}`, 'anomaly');
                    imagenDisplay.innerHTML = `<span class="text-[var(--danger-color)]">Kunne ikke generere bilde.</span>`;
                }
            }

            function displayChatMessage(message, sender) {
                const messageEl = document.createElement('div');
                messageEl.classList.add(sender === 'user' ? 'chat-user' : 'chat-assistant');
                messageEl.innerHTML = message;
                chatHistoryEl.appendChild(messageEl);
                chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
            }

            async function handleChatQuery(query) {
                if (!checkApiKey()) return;
                displayChatMessage(query, 'user');
                const thinkingEl = document.createElement('div');
                thinkingEl.classList.add('chat-assistant');
                thinkingEl.innerText = 'Tenker...';
                chatHistoryEl.appendChild(thinkingEl);
                chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
                const logContext = Array.from(logList.querySelectorAll('li')).slice(0, 30).map(li => li.textContent).join('\n');
                const prompt = `Du er CORTEX-assistenten, en AI innebygd i et overv√•kingssystem. Svar p√• operat√∏rens sp√∏rsm√•l kort og presist basert p√• systemloggene du f√•r oppgitt.\n\nSYSTEMLOGGER:\n${logContext}\n\nOPERAT√òRENS SP√òRSM√ÖL: "${query}"\n\nDITT SVAR:`;
                try {
                    const response = await callGeminiAPI(prompt, []);
                    thinkingEl.remove();
                    displayChatMessage(response.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li>$1</li>').replace(/(\n)/g, '<br>'), 'assistant');
                } catch (error) {
                    thinkingEl.remove();
                    displayChatMessage(`<span class="text-[var(--danger-color)]">Systemfeil i assistent-modul: ${error.message}</span>`, 'assistant');
                }
            }

            function runGabrielProtocol() {
                 protocolTitle.innerText = 'PROTOKOLL GABRIEL: INFORMASJONSINTEGRITET';
                protocolContent.innerHTML = createLoader('Verifiserer database...');
                protocolModal.classList.remove('hidden');
                if (knownFaceDescriptors.length === 0) {
                    protocolContent.innerHTML = '<p class="text-yellow-400">Database er tom. Ingen data √• verifisere.</p>';
                    return;
                }
                setTimeout(() => {
                    try {
                        const dataStr = JSON.stringify(knownFaceDescriptors.map(fd => fd.toJSON()));
                        let checksum = 0;
                        for (let i = 0; i < dataStr.length; i++) {
                            checksum = (checksum + dataStr.charCodeAt(i) * (i + 1)) % 65536;
                        }
                        protocolContent.innerHTML = `<p>Databaseintegritet verifisert.</p><p>Antall kjente individer: <span class="text-[var(--primary-color)]">${knownFaceDescriptors.length}</span></p><p>Sjekksum (HEX): <span class="text-[var(--primary-color)]">${checksum.toString(16).toUpperCase()}</span></p><p class="mt-4 text-green-400">STATUS: SIKKER</p>`;
                    } catch (e) {
                         protocolContent.innerHTML = `<p class="text-[var(--danger-color)]">Kritisk feil under verifisering: ${e.message}</p>`;
                    }
                }, 1000);
            }

            async function runRafaelProtocol() {
                if (!checkApiKey()) return;
                protocolTitle.innerText = 'PROTOKOLL RAFAEL: TRANSPORTANALYSE';
                protocolContent.innerHTML = createLoader('Fanger bildesekvens...');
                protocolModal.classList.remove('hidden');
                const delay = parseInt(intervalInput.value, 10);
                const imageSequence = await captureFrameSequence(3, delay);
                protocolContent.innerHTML = createLoader('Analyserer sekvens...');
                const prompt = `Du er AI-protokoll RAFAEL. Du har mottatt en sekvens p√• ${imageSequence.length} bilder tatt over et kort tidsrom. Analyser bevegelsen og flyten **mellom bildene**. Gi en kort, punktliste-basert vurdering av:\n- **Flyt:** Er bevegelsen i scenen jevn, stillest√•ende eller kaotisk?\n- **Tetthet:** Endrer tettheten av personer seg? Oppst√•r det unormale samlinger?\n- **M√∏nster:** Identifiser hovedretningen p√• bevegelsen. Er det noen som beveger seg mot str√∏mmen eller p√• en uventet m√•te?\n- **Konklusjon:** Gi en overordnet status (f.eks., "NORMAL FLYT", "POTENSIELL FLASKEHALS DETEKTERT", "UNORMAL SAMLING").`;
                 try {
                    const responseText = await callGeminiAPI(prompt, imageSequence);
                    protocolContent.innerHTML = responseText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li class="ml-4 list-disc">$1</li>').replace(/(\n)/g, '<br>');
                } catch (error) {
                    protocolContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under transportanalyse: ${error.message}</p>`;
                }
            }
            
            async function runUrielProtocol() {
                if (!checkApiKey()) return;
                protocolTitle.innerText = 'PROTOKOLL URIEL: OMGIVELSESANALYSE';
                protocolContent.innerHTML = createLoader('Skanner omgivelsene for avvik...');
                protocolModal.classList.remove('hidden');
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                tempCanvas.getContext('2d').drawImage(video, 0, 0);
                const base64ImageData = tempCanvas.toDataURL('image/jpeg').split(',')[1];
                
                const prompt = `Du er AI-protokoll URIEL, en ekspert i situasjonsbevissthet. Analyser dette bildet fra et overv√•kingskamera. Se bort fra personene, og fokuser utelukkende p√• **omgivelsene**. Identifiser potensielle sikkerhetsrisikoer eller avvik.
                - Se etter **gjenglemte gjenstander** (vesker, sekker, bokser) uten en √•penbar eier i n√¶rheten.
                - Se etter **milj√∏messige avvik** (√•pne d√∏rer som burde v√¶rt lukket, hindringer i passasjer, skade p√• utstyr).
                - Gi en kort, punktliste-basert rapport. Hvis ingen avvik finnes, rapporter "Ingen milj√∏avvik detektert."`;

                 try {
                    const responseText = await callGeminiAPI(prompt, [base64ImageData]);
                    protocolContent.innerHTML = responseText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li class="ml-4 list-disc">$1</li>').replace(/(\n)/g, '<br>');
                } catch (error) {
                    protocolContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under omgivelsesanalyse: ${error.message}</p>`;
                }
            }
            
            async function runSandalphonProtocol() {
                if (!checkApiKey()) return;
                protocolTitle.innerText = 'PROTOKOLL SANDALPHON: INTERAKSJONSANALYSE';
                protocolContent.innerHTML = createLoader('Analyserer sosial dynamikk...');
                protocolModal.classList.remove('hidden');
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                tempCanvas.getContext('2d').drawImage(video, 0, 0);
                const base64ImageData = tempCanvas.toDataURL('image/jpeg').split(',')[1];
                
                const prompt = `Du er AI-protokoll SANDALPHON. Analyser dette bildet fra et overv√•kingskamera som viser en gruppe mennesker.
                - **Beskriv interaksjonen:** Hva foreg√•r mellom personene? Snakker de, krangler de, utveksler de noe, eller ignorerer de hverandre?
                - **Vurder stemningen:** Er den generelle stemningen i gruppen positiv, negativ, n√∏ytral eller anspent?
                - **Identifiser n√∏kkelpersoner:** Er det noen som virker som en leder, en outsider, eller en agitator i gruppen?
                - **Konklusjon:** Gi en overordnet status (f.eks., "Normal sosial interaksjon", "Opphetet diskusjon", "Potensiell konflikt under utvikling").`;

                 try {
                    const responseText = await callGeminiAPI(prompt, [base64ImageData]);
                    protocolContent.innerHTML = responseText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\* (.+)/g, '<li class="ml-4 list-disc">$1</li>').replace(/(\n)/g, '<br>');
                    addLog('Sandalphon-analyse fullf√∏rt.', 'known');
                } catch (error) {
                    protocolContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under interaksjonsanalyse: ${error.message}</p>`;
                    addLog('Sandalphon-protokoll feilet.', 'anomaly');
                }
            }

            async function runMetatronProtocol() {
                if (!checkApiKey()) return;

                metatronPredictionContent.innerHTML = createLoader('Initialiserer prediktiv analyse...');
                confidenceBar.style.width = '0%';
                confidenceText.textContent = '0%';
                metatronFramesContainer.innerHTML = Array(5).fill('<div class="aspect-video bg-black/50 animate-pulse"></div>').join('');
                metatronModal.classList.remove('hidden');

                addLog('Aktiverer Protokoll METATRON...', 'system');
                
                const delay = parseInt(intervalInput.value, 10);
                const imageSequence = await captureFrameSequence(5, delay);
                
                metatronFramesContainer.innerHTML = '';
                imageSequence.forEach(frame => {
                    const img = document.createElement('img');
                    img.src = `data:image/jpeg;base64,${frame}`;
                    img.className = 'w-full h-auto object-cover border border-[var(--primary-color)]/50';
                    metatronFramesContainer.appendChild(img);
                });

                metatronPredictionContent.innerHTML = createLoader('AI analyserer sekvens for intensjon...');

                const prompt = `Prompt fra Operat√∏r Jon-Arve Constantine Gr√∏nsberg-Ovesen:
                Du er AI-protokoll METATRON, en ekspert i prediktiv adferdsanalyse. Du har mottatt en sekvens p√• ${imageSequence.length} bilder av et subjekt. Analyser endringene i kroppsspr√•k, ansiktsuttrykk og positur mellom bildene for √• forutsi subjektets mest sannsynlige umiddelbare intensjon eller neste handling. Svar med et JSON-objekt som f√∏lger det gitte skjemaet.
                - Vurder om subjektet blir mer eller mindre anspent, aggressivt, eller om det forbereder seg p√• en spesifikk handling (f.eks., √• reise seg, l√∏pe, angripe, snakke).
                - Baser konfidensscoren p√• hvor tydelige og konsistente signalene er gjennom sekvensen.`;
                
                const schema = {
                    type: "OBJECT",
                    properties: {
                        prediction_text: { type: "STRING", description: "En kort, konsis setning som beskriver den mest sannsynlige neste handlingen eller intensjonen." },
                        confidence_score: { type: "NUMBER", description: "Et tall mellom 0.0 og 1.0 som representerer din konfidens i prediksjonen." },
                        reasoning: { type: "STRING", description: "En kort setning som forklarer hvilke visuelle hint som f√∏rte til prediksjonen." }
                    },
                    required: ["prediction_text", "confidence_score", "reasoning"]
                };

                try {
                    const data = await callGeminiAPI(prompt, imageSequence, schema);
                    metatronPredictionContent.innerHTML = `<p class="text-xl text-[var(--primary-color)]">${data.prediction_text || "Ingen klar prediksjon."}</p><p class="mt-4 text-gray-400"><strong>Begrunnelse:</strong> ${data.reasoning || "Utilgjengelig."}</p>`;
                    const confidencePercent = Math.round((data.confidence_score || 0) * 100);
                    confidenceText.textContent = `${confidencePercent}%`;
                    setTimeout(() => { confidenceBar.style.width = `${confidencePercent}%`; }, 100);
                    addLog(`METATRON Prediksjon: ${data.prediction_text} (Konfidens: ${confidencePercent}%)`, 'known');
                } catch (error) {
                    metatronPredictionContent.innerHTML = `<p class="text-[var(--danger-color)]">FEIL under prediktiv analyse: ${error.message}</p>`;
                    addLog(`METATRON-protokoll feilet: ${error.message}`, 'anomaly');
                }
            }
            
            function updateFaceMatcher() { 
                const tolerance = parseFloat(toleranceSlider.value);
                if (knownFaceDescriptors.length > 0) { 
                    faceMatcher = new faceapi.FaceMatcher(knownFaceDescriptors, tolerance); 
                    saveBtn.disabled = false; 
                } else { 
                    faceMatcher = null; 
                    saveBtn.disabled = true; 
                } 
                updateKnownFacesListUI(); 
            }

            function updateKnownFacesListUI() { 
                knownFacesList.innerHTML = ''; 
                knownFaceDescriptors.forEach(fd => { 
                    const li = document.createElement('li'); 
                    li.textContent = `> ${fd.label}`; 
                    knownFacesList.appendChild(li); 
                }); 
            }
             
            async function handleUnknownFace(descriptor) {
                if (unknownFaceDescriptors.length > 0) {
                    const unknownMatcher = new faceapi.FaceMatcher(unknownFaceDescriptors, 0.6);
                    const bestMatch = unknownMatcher.findBestMatch(descriptor);
                    if (bestMatch.label !== 'unknown') return;
                }
                const newUnknown = new faceapi.LabeledFaceDescriptors(`ukjent_${Date.now()}`, [descriptor]);
                unknownFaceDescriptors.push(newUnknown);
                addLog('Ukjent ansikt lagret. "Eksporter Ukjente" er n√• tilgjengelig.', 'system');
                saveUnknownBtn.disabled = false;
            }
            
            async function detectFacesLoop() {
                if (video.paused || video.ended || video.videoWidth === 0) return;
                const displaySize = { width: video.clientWidth, height: video.clientHeight };
                if (displaySize.width === 0 || displaySize.height === 0) return; 

                faceapi.matchDimensions(overlay, displaySize);
                const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.5 })).withFaceLandmarks().withFaceDescriptors();
                const resizedDetections = faceapi.resizeResults(detections, displaySize);
                const ctx = overlay.getContext('2d');
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                if (detections.length === 0) toggleImagenButton(false);
                for (const detection of resizedDetections) {
                    let label = 'ANOMALI: UKJENT';
                    let color = 'rgba(255, 51, 51, 0.8)';
                    if (faceMatcher) {
                        const bestMatch = faceMatcher.findBestMatch(detection.descriptor);
                        if (bestMatch.label !== 'unknown') {
                            label = `${bestMatch.label} (${Math.round((1 - bestMatch.distance) * 100)}%)`;
                            color = 'rgba(0, 255, 204, 0.8)';
                        } else { await handleUnknownFace(detection.descriptor); }
                    } else { await handleUnknownFace(detection.descriptor); }
                    new faceapi.draw.DrawBox(detection.detection.box, { label, boxColor: color, drawLabelOptions: { fontColor: '#fff', backgroundColor: color } }).draw(overlay);
                }
            }

            // --- Event Listeners ---
            saveApiKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();
                if (key) {
                    userApiKey = key;
                    addLog('API N√∏kkel lagret og AI-funksjoner aktivert.', 'known');
                    behaviorBtn.disabled = false;
                    reportBtn.disabled = false;
                    summaryBtn.disabled = false;
                    chatInput.disabled = false;
                    chatSubmitBtn.disabled = false;
                    rafaelBtn.disabled = false;
                    metatronBtn.disabled = false;
                    urielBtn.disabled = false;
                    sandalphonBtn.disabled = false;
                } else {
                    addLog('API N√∏kkel-feltet er tomt.', 'anomaly');
                }
            });

            toleranceSlider.addEventListener('input', (e) => {
                toleranceValue.textContent = e.target.value;
                updateFaceMatcher();
            });

            captureBtn.addEventListener('click', async () => {
                addLog('Analyserer for registrering...', 'system');
                const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();
                if (detection) {
                    lastCapturedDescriptor = detection.descriptor;
                    addLog('Tydelig ansikt funnet.', 'system');
                    modalBackdrop.classList.remove('hidden');
                } else {
                    addLog('Kunne ikke finne ansikt for registrering.', 'anomaly');
                    lastCapturedDescriptor = null;
                }
            });

            submitNameBtn.addEventListener('click', () => {
                const name = nameInput.value.trim();
                if (!name || !lastCapturedDescriptor) { return addLog('Registrering feilet: Data mangler.', 'anomaly'); }
                try {
                    knownFaceDescriptors.push(new faceapi.LabeledFaceDescriptors(name, [lastCapturedDescriptor]));
                    updateFaceMatcher();
                    addLog(`Individ '${name}' registrert. 'Eksporter DB' er n√• tilgjengelig.`, 'known');
                    modalBackdrop.classList.add('hidden');
                    nameInput.value = '';
                    lastCapturedDescriptor = null;
                } catch (error) { addLog(`KRITISK LAGRINGSFEIL: ${error.message}`, 'anomaly'); }
            });
            
            saveUnknownBtn.addEventListener('click', () => {
                if (unknownFaceDescriptors.length === 0) return addLog('Ingen ukjente ansikter √• eksportere.', 'system');
                const dataStr = JSON.stringify(unknownFaceDescriptors.map(fd => fd.toJSON()), null, 2);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([dataStr], { type: 'application/json' }));
                a.download = 'cortex_unknown_faces.json';
                a.click();
                URL.revokeObjectURL(a.href);
                addLog('Database med ukjente ansikter eksportert.', 'known');
            });

            saveBtn.addEventListener('click', () => {
                if (knownFaceDescriptors.length === 0) return addLog('Database med kjente fjes er tom. Registrer et fjes f√∏rst.', 'anomaly');
                const dataStr = JSON.stringify(knownFaceDescriptors.map(fd => fd.toJSON()), null, 2);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([dataStr], { type: 'application/json' }));
                a.download = 'cortex_known_faces_database.json';
                a.click();
                URL.revokeObjectURL(a.href);
                addLog('Database med kjente ansikter eksportert.', 'known');
            });

            loadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedData = JSON.parse(event.target.result).map(fd => faceapi.LabeledFaceDescriptors.fromJSON(fd));
                        const existingLabels = new Set(knownFaceDescriptors.map(d => d.label));
                        const newData = loadedData.filter(d => !existingLabels.has(d.label));
                        knownFaceDescriptors.push(...newData);
                        updateFaceMatcher();
                        addLog(`${newData.length} nye individer lagt til i databasen fra fil.`, 'known');
                    } catch (err) {
                        addLog('FEIL: Kunne ikke lese fil.', 'anomaly');
                    } finally { e.target.value = ''; }
                };
                reader.readAsText(file);
            });
            
            video.addEventListener('play', () => {
                loadingMessage.style.display = 'none';
                addLog('System klart. Overv√•king aktiv.', 'known');
                detectionInterval = setInterval(detectFacesLoop, 350);
            });
            
            chatForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const query = chatInput.value.trim();
                if(query) {
                    handleChatQuery(query);
                    chatInput.value = '';
                }
            });
            
            modalBackdrop.addEventListener('click', (e) => { if (e.target === modalBackdrop) modalBackdrop.classList.add('hidden'); });
            reportBtn.addEventListener('click', generateAndDisplayReport);
            behaviorBtn.addEventListener('click', analyzeBehavior);
            
            closeReportBtn.addEventListener('click', () => reportModal.classList.add('hidden'));
            closeBehaviorBtn.addEventListener('click', () => {
                behaviorModal.classList.add('hidden');
                toggleImagenButton(false);
            });
            closeImagenBtn.addEventListener('click', () => imagenModal.classList.add('hidden'));
            generateImagenBtn.addEventListener('click', () => {
                const promptText = imagenPrompt.value.trim();
                if (promptText) { callImagenAPI(promptText); } 
                else { addLog('Vennligst skriv inn en beskrivelse for fantombildet.', 'anomaly'); }
            });
            gabrielBtn.addEventListener('click', runGabrielProtocol);
            rafaelBtn.addEventListener('click', runRafaelProtocol);
            closeProtocolBtn.addEventListener('click', () => protocolModal.classList.add('hidden'));
            summaryBtn.addEventListener('click', generateLogSummary);
            closeSummaryBtn.addEventListener('click', () => summaryModal.classList.add('hidden'));
            metatronBtn.addEventListener('click', runMetatronProtocol);
            closeMetatronBtn.addEventListener('click', () => metatronModal.classList.add('hidden'));
            helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeHelpBtn.addEventListener('click', () => helpModal.classList.add('hidden'));
            urielBtn.addEventListener('click', runUrielProtocol);
            sandalphonBtn.addEventListener('click', runSandalphonProtocol);
            cameraSelect.addEventListener('change', (e) => startStream(e.target.value));
            
            helpTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const target = tab.dataset.tab;
                    helpTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    helpTabContents.forEach(c => {
                        if (c.id === `${target}-content`) {
                            c.classList.remove('hidden');
                        } else {
                            c.classList.add('hidden');
                        }
                    });
                });
            });
            // Make the first tab active by default
            if(helpTabs.length > 0) helpTabs[0].classList.add('active');
            if(helpTabContents.length > 0) helpTabContents[0].classList.remove('hidden');

            enterAppBtn.addEventListener('click', startApp);
            eoBtn.addEventListener('click', () => eoModal.classList.remove('hidden'));
            closeEoBtn.addEventListener('click', () => eoModal.classList.add('hidden'));
            
            // GitHub event listeners
            githubSyncBtn.addEventListener('click', () => {
                if (isGithubConnected) {
                    syncToGithub();
                } else {
                    githubAuthModal.classList.remove('hidden');
                }
            });
            
            githubLoginBtn.addEventListener('click', authenticateGithub);
            githubSetupRepoBtn.addEventListener('click', setupGithubRepository);
            githubDisconnectBtn.addEventListener('click', disconnectGithub);
            closeGithubAuthBtn.addEventListener('click', () => githubAuthModal.classList.add('hidden'));
            
            // Handle Enter key in token input
            githubTokenInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    authenticateGithub();
                }
            });
            
            // Handle Enter key in repo input
            githubRepoInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    setupGithubRepository();
                }
            });

            initialize();
        });
    </script>
</body>
</html>
